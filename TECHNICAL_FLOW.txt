================================================================================
                    WEBSENSE-AI TECHNICAL FLOW DOCUMENTATION
================================================================================

PROJECT OVERVIEW
================================================================================
WebSense-AI is a Chrome Extension with voice-controlled web automation powered by
NLP (Natural Language Processing) using spaCy. The system consists of three main
components:

1. Chrome Extension (Frontend) - Manifest V3
2. Node.js Backend API Server (Port 3000)
3. Python spaCy NLP Server (Port 5001)

ARCHITECTURE COMPONENTS
================================================================================

1. CHROME EXTENSION (Extension/)
   â”œâ”€â”€ Background Script (background/background.js)
   â”‚   - Service worker running in background
   â”‚   - Listens for keyboard shortcuts (Ctrl+Shift+V)
   â”‚   - Injects voice control into active tabs
   â”‚   - Manages tab lifecycle and navigation events
   â”‚
   â”œâ”€â”€ Content Script (dist/voiceControl.js - 2641 lines)
   â”‚   - Injected into web pages
   â”‚   - Handles speech recognition (Web Speech API)
   â”‚   - Manages UI (floating mic button)
   â”‚   - Processes voice commands
   â”‚   - Interacts with DOM elements
   â”‚
   â””â”€â”€ Popup UI (popup/App.jsx)
       - Extension popup interface
       - Quick access controls
       - Status display

2. NODE.JS BACKEND (backend/)
   â”œâ”€â”€ Server (server.js - Port 3000)
   â”‚   - Express.js REST API
   â”‚   - CORS middleware for extension access
   â”‚   - Rate limiting and security
   â”‚
   â”œâ”€â”€ Routes
   â”‚   - /api/health - Health check endpoint
   â”‚   - /api/summarize - Text summarization (OpenAI)
   â”‚   - /api/translate - Language translation (Google)
   â”‚   - /api/vision - Image analysis (Google Vision)
   â”‚
   â””â”€â”€ Services
       - openai.js - GPT integration
       - googleTranslate.js - Translation API
       - googleVision.js - Image recognition
       - safeBrowsing.js - Security checking

3. PYTHON NLP SERVER (backend/nlp/)
   â””â”€â”€ spacy_server.py (Port 5001)
       - Flask REST API
       - spaCy NLP processing
       - Command intent classification
       - Entity extraction
       - Action execution logic

COMPLETE TECHNICAL FLOW
================================================================================

INITIALIZATION FLOW:
--------------------

Step 1: Extension Installation
   - Chrome loads manifest.json
   - Background script registers
   - Sets up keyboard listener (Ctrl+Shift+V)

Step 2: User Activates Voice Control (Ctrl+Shift+V)
   
   background.js Line 105-145:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ function injectVoiceControl(tabId)                          â”‚
   â”‚   â”œâ”€â”€ Check cooldown (2-second protection)                  â”‚
   â”‚   â”œâ”€â”€ Execute script: dist/voiceControl.js                  â”‚
   â”‚   â””â”€â”€ Mark tab as injected                                  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: Voice Control Injection into Page

   voiceControl.js Line 1-48:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ IIFE (Immediately Invoked Function Expression)              â”‚
   â”‚   â”œâ”€â”€ Check if already active (wsVoiceControlActive)        â”‚
   â”‚   â”œâ”€â”€ Create cleanup handlers (beforeunload, pagehide)      â”‚
   â”‚   â”œâ”€â”€ Remove old UI if exists                               â”‚
   â”‚   â””â”€â”€ Initialize system                                     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 4: UI Creation

   voiceControl.js Line 128-250:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Create Floating UI Wrapper                                  â”‚
   â”‚   â”œâ”€â”€ Position: fixed, bottom-right (20px)                  â”‚
   â”‚   â”œâ”€â”€ Z-index: 2147483647 (always on top)                   â”‚
   â”‚   â”œâ”€â”€ Display: flex (always visible)                        â”‚
   â”‚   â”œâ”€â”€ Mic Button: ğŸ¤ (gray when stopped, ğŸ”´ red when active)â”‚
   â”‚   â””â”€â”€ Inject into document.body                             â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 5: Element Cache Initialization

   voiceControl.js Line 252-349:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ updateElementCache()                                         â”‚
   â”‚   â”œâ”€â”€ Query all buttons: querySelector('button, [role...]') â”‚
   â”‚   â”œâ”€â”€ Query all links: querySelectorAll('a[href]')          â”‚
   â”‚   â”œâ”€â”€ Query clickables: input[type="submit"], select, etc.  â”‚
   â”‚   â”œâ”€â”€ Filter visible elements only                          â”‚
   â”‚   â”œâ”€â”€ Store in elementCache object                          â”‚
   â”‚   â””â”€â”€ Log cache stats with performance timing               â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 6: MutationObserver Setup

   voiceControl.js Line 350-452:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ setupDOMObserver()                                           â”‚
   â”‚   â”œâ”€â”€ Watch for: childList, subtree, attributes             â”‚
   â”‚   â”œâ”€â”€ Detect important changes (menus, dialogs, nav)        â”‚
   â”‚   â”œâ”€â”€ Immediate update for important changes (0ms)          â”‚
   â”‚   â”œâ”€â”€ Debounced update for normal changes (200ms)           â”‚
   â”‚   â””â”€â”€ Return observer instance                              â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 7: Speech Recognition Setup

   voiceControl.js Line 1166-1187:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ const recognition = new webkitSpeechRecognition()           â”‚
   â”‚   â”œâ”€â”€ continuous: true (keeps listening)                    â”‚
   â”‚   â”œâ”€â”€ interimResults: true (real-time feedback)             â”‚
   â”‚   â”œâ”€â”€ lang: 'en-US'                                         â”‚
   â”‚   â””â”€â”€ maxAlternatives: 1                                    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 8: Auto-Start Listening

   voiceControl.js Line 2495-2540:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Auto-start on injection                                      â”‚
   â”‚   â”œâ”€â”€ Wait for voices to load (speechSynthesis)             â”‚
   â”‚   â”œâ”€â”€ Check if domain already welcomed                      â”‚
   â”‚   â”œâ”€â”€ If new domain: speak "Voice control activated..."     â”‚
   â”‚   â”œâ”€â”€ If known domain: silently start                       â”‚
   â”‚   â”œâ”€â”€ Set isListening = true                                â”‚
   â”‚   â”œâ”€â”€ Change button: ğŸ”´ (red background)                    â”‚
   â”‚   â””â”€â”€ Call recognition.start()                              â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VOICE COMMAND PROCESSING FLOW
================================================================================

USER SPEAKS â†’ SPEECH RECOGNITION â†’ NLP ANALYSIS â†’ ACTION EXECUTION â†’ RESPONSE

Detailed Step-by-Step:

1. USER SPEAKS COMMAND
   Example: "Click on login button"

2. SPEECH RECOGNITION CAPTURES AUDIO

   voiceControl.js Line 1246-1270 (recognition.onresult):
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Event: recognition.onresult                                  â”‚
   â”‚   â”œâ”€â”€ Extract transcript from event.results                 â”‚
   â”‚   â”œâ”€â”€ Check if final result                                 â”‚
   â”‚   â”œâ”€â”€ Log transcript to console                             â”‚
   â”‚   â””â”€â”€ Call processCommand(transcript)                       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   
   Output: transcript = "click on login button"

3. COMMAND PREPROCESSING

   voiceControl.js Line 560-620 (processCommand):
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ processCommand(transcript)                                   â”‚
   â”‚   â”œâ”€â”€ Normalize: toLowerCase(), trim()                      â”‚
   â”‚   â”œâ”€â”€ Check for conversational keywords                     â”‚
   â”‚   â”‚   - "hello", "hi", "hey" â†’ greet action                 â”‚
   â”‚   â”‚   - "thank", "thanks" â†’ thank action                    â”‚
   â”‚   â”‚   - "yes", "okay", "sure" â†’ confirm action              â”‚
   â”‚   â”‚   - "no", "nope", "cancel" â†’ deny action                â”‚
   â”‚   â”‚   - "help", "what can you do" â†’ help action             â”‚
   â”‚   â”œâ”€â”€ If not conversational â†’ send to NLP server            â”‚
   â”‚   â””â”€â”€ Handle response                                       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4. SEND TO SPACY NLP SERVER

   voiceControl.js Line 770-850 (sendToSpacyServer):
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ API Call to http://localhost:5001/process                   â”‚
   â”‚                                                              â”‚
   â”‚ Request:                                                     â”‚
   â”‚   POST /process                                              â”‚
   â”‚   Content-Type: application/json                            â”‚
   â”‚   Body: {                                                    â”‚
   â”‚     "text": "click on login button",                        â”‚
   â”‚     "page_title": document.title,                           â”‚
   â”‚     "url": window.location.href                             â”‚
   â”‚   }                                                          â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5. SPACY NLP PROCESSING

   spacy_server.py Line 200-450 (process_text endpoint):
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Flask Route: @app.route('/process', methods=['POST'])       â”‚
   â”‚                                                              â”‚
   â”‚ Step 1: Parse JSON request                                  â”‚
   â”‚   text = "click on login button"                            â”‚
   â”‚   page_title = "Example Website"                            â”‚
   â”‚   url = "https://example.com"                               â”‚
   â”‚                                                              â”‚
   â”‚ Step 2: Process with spaCy                                  â”‚
   â”‚   doc = nlp(text.lower())                                   â”‚
   â”‚   tokens = [token.text for token in doc]                    â”‚
   â”‚   pos_tags = [token.pos_ for token in doc]                  â”‚
   â”‚                                                              â”‚
   â”‚ Step 3: Extract intent (action)                             â”‚
   â”‚   analyze_intent(text, doc)                                 â”‚
   â”‚     â”œâ”€â”€ Check keywords: "click" in text                     â”‚
   â”‚     â”œâ”€â”€ Action detected: "click"                            â”‚
   â”‚     â””â”€â”€ Confidence: 0.95                                    â”‚
   â”‚                                                              â”‚
   â”‚ Step 4: Extract entities (target)                           â”‚
   â”‚   extract_entities(doc, intent)                             â”‚
   â”‚     â”œâ”€â”€ Look for nouns after "click on"                     â”‚
   â”‚     â”œâ”€â”€ Found: "login button"                               â”‚
   â”‚     â””â”€â”€ Target: "login button"                              â”‚
   â”‚                                                              â”‚
   â”‚ Step 5: Generate response                                   â”‚
   â”‚   generate_response(intent, entities)                       â”‚
   â”‚     â”œâ”€â”€ Select random response template                     â”‚
   â”‚     â””â”€â”€ Response: "Clicking on login button"                â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   Response JSON:
   {
     "action": "click",
     "target": "login button",
     "confidence": 0.95,
     "response": "Clicking on login button",
     "entities": ["login", "button"],
     "tokens": ["click", "on", "login", "button"],
     "pos_tags": ["VERB", "ADP", "NOUN", "NOUN"]
   }

6. ACTION EXECUTION IN BROWSER

   voiceControl.js Line 900-1100 (executeAction):
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ executeAction(actionData)                                    â”‚
   â”‚                                                              â”‚
   â”‚ Step 1: Speak response                                      â”‚
   â”‚   smartSpeak("Clicking on login button")                    â”‚
   â”‚                                                              â”‚
   â”‚ Step 2: Find matching element                               â”‚
   â”‚   findMatchingElement(target, elementCache.buttons)         â”‚
   â”‚     â”œâ”€â”€ Search in button text: "Login", "Sign In"           â”‚
   â”‚     â”œâ”€â”€ Check aria-label attributes                         â”‚
   â”‚     â”œâ”€â”€ Check button IDs                                    â”‚
   â”‚     â””â”€â”€ Match found: <button id="login-btn">Login</button>  â”‚
   â”‚                                                              â”‚
   â”‚ Step 3: Highlight element                                   â”‚
   â”‚   element.style.outline = '3px solid #ff6b6b'               â”‚
   â”‚   element.style.boxShadow = '0 0 10px rgba(255,107,107,0.5)'â”‚
   â”‚                                                              â”‚
   â”‚ Step 4: Click element                                       â”‚
   â”‚   element.scrollIntoView({ behavior: 'smooth' })            â”‚
   â”‚   setTimeout(() => {                                        â”‚
   â”‚     element.click()                                         â”‚
   â”‚   }, 500)                                                   â”‚
   â”‚                                                              â”‚
   â”‚ Step 5: Store in context                                    â”‚
   â”‚   contextManager.remember('click', 'login button', [elem])  â”‚
   â”‚                                                              â”‚
   â”‚ Step 6: Remove highlight                                    â”‚
   â”‚   setTimeout(() => removeHighlights(), 2000)                â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

7. CONTINUE LISTENING

   voiceControl.js Line 1188-1220 (recognition.onend):
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Event: recognition.onend                                     â”‚
   â”‚   â”œâ”€â”€ Check if should restart (isListening === true)        â”‚
   â”‚   â”œâ”€â”€ Wait 300ms (prevent rapid restarts)                   â”‚
   â”‚   â””â”€â”€ Call recognition.start() again                        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

API ENDPOINTS REFERENCE
================================================================================

1. SPACY NLP SERVER (http://localhost:5001)

   POST /process
   â”œâ”€â”€ Purpose: Process natural language commands
   â”œâ”€â”€ Input: {"text": "command", "page_title": "...", "url": "..."}
   â”œâ”€â”€ Output: {"action": "...", "target": "...", "confidence": 0.95, ...}
   â””â”€â”€ Processing time: ~50-200ms

   GET /health
   â”œâ”€â”€ Purpose: Check server status
   â””â”€â”€ Output: {"status": "ok", "model": "en_core_web_sm"}

2. NODE.JS BACKEND (http://localhost:3000)

   GET /api/health
   â”œâ”€â”€ Purpose: Health check
   â””â”€â”€ Output: {"status": "ok", "timestamp": "..."}

   POST /api/summarize
   â”œâ”€â”€ Purpose: Summarize text using OpenAI GPT
   â”œâ”€â”€ Input: {"text": "long text...", "maxLength": 100}
   â””â”€â”€ Output: {"summary": "shortened text..."}

   POST /api/translate
   â”œâ”€â”€ Purpose: Translate text using Google Translate
   â”œâ”€â”€ Input: {"text": "Hello", "targetLang": "es"}
   â””â”€â”€ Output: {"translation": "Hola", "sourceLang": "en"}

   POST /api/vision
   â”œâ”€â”€ Purpose: Analyze images using Google Vision
   â”œâ”€â”€ Input: {"imageUrl": "https://..."}
   â””â”€â”€ Output: {"labels": [...], "text": "...", "safe": true}

KEY FUNCTIONS REFERENCE
================================================================================

CHROME EXTENSION FUNCTIONS:

1. injectVoiceControl(tabId)
   Location: background.js:105-145
   Purpose: Inject voice control script into active tab
   Parameters: tabId (Chrome tab ID)
   Returns: Promise
   Dependencies: chrome.scripting.executeScript

2. updateElementCache()
   Location: voiceControl.js:252-349
   Purpose: Scan page and cache all interactive elements
   Updates: elementCache.buttons, elementCache.links, elementCache.clickables
   Performance: ~10-50ms depending on page complexity

3. setupDOMObserver()
   Location: voiceControl.js:350-452
   Purpose: Watch for DOM changes (new elements, menus, dropdowns)
   Returns: MutationObserver instance
   Triggers: updateElementCache() on changes
   Debounce: 200ms (normal), 0ms (important changes)

4. processCommand(transcript)
   Location: voiceControl.js:560-620
   Purpose: Main command processing pipeline
   Flow: Normalize â†’ Check conversational â†’ Send to NLP â†’ Execute
   Parameters: transcript (string from speech recognition)

5. sendToSpacyServer(text)
   Location: voiceControl.js:770-850
   Purpose: Send command to NLP server for analysis
   Method: POST fetch to localhost:5001/process
   Timeout: 5000ms
   Error handling: Network errors, server errors

6. executeAction(actionData)
   Location: voiceControl.js:900-1100
   Purpose: Execute parsed action on page
   Actions: click, type, scroll, navigate, read, search
   Flow: Speak â†’ Find element â†’ Highlight â†’ Execute â†’ Store context

7. findMatchingElement(target, elements)
   Location: voiceControl.js:1120-1165
   Purpose: Find best matching element from cache
   Matching: Text content, aria-label, ID, class, title
   Algorithm: Fuzzy matching with similarity scoring
   Returns: DOM element or null

8. smartSpeak(text, callback)
   Location: voiceControl.js:2200-2280
   Purpose: Text-to-speech with voice selection
   Uses: SpeechSynthesisUtterance
   Voice: Prefers female English voices
   Rate: 1.1x (slightly faster)
   Pitch: 1.0 (normal)

9. cleanup()
   Location: voiceControl.js:13-48
   Purpose: Clean up on page unload/navigation
   Actions: Stop recognition, cancel speech, reset flags
   Triggers: beforeunload, pagehide events

SPACY SERVER FUNCTIONS:

1. analyze_intent(text, doc)
   Location: spacy_server.py:450-650
   Purpose: Classify command intent/action
   Algorithm: Keyword matching + dependency parsing
   Actions: click, type, scroll, navigate, read, search, greet, thank, etc.
   Returns: (action, confidence)

2. extract_entities(doc, intent)
   Location: spacy_server.py:652-750
   Purpose: Extract target entities (buttons, links, text)
   Methods: NER, noun chunks, dependency relations
   Returns: List of entity strings

3. generate_response(intent, entities)
   Location: spacy_server.py:752-850
   Purpose: Generate natural language response
   Responses: 6-15 variations per action type
   Selection: Random choice for variety
   Returns: Response string

4. handle_conversational(intent, entities)
   Location: spacy_server.py:300-400
   Purpose: Handle greetings, thanks, confirmations
   Keywords: 30+ per category
   Responses: 6-8 variations
   Returns: Response JSON

STORAGE AND STATE MANAGEMENT
================================================================================

1. CHROME STORAGE (chrome.storage.local)
   
   welcomedDomains: Array<string>
   â”œâ”€â”€ Purpose: Track domains that received welcome message
   â”œâ”€â”€ Max size: 50 most recent domains
   â””â”€â”€ Format: ["youtube.com", "github.com", "example.com"]

2. ELEMENT CACHE (in-memory)
   
   elementCache = {
     buttons: Array<HTMLElement>,
     links: Array<HTMLElement>,
     clickables: Array<HTMLElement>,
     lastUpdate: timestamp
   }
   â”œâ”€â”€ Updated by: MutationObserver, scroll, DOMContentLoaded
   â”œâ”€â”€ Refresh rate: On-demand (smart debouncing)
   â””â”€â”€ Typical size: 50-500 elements depending on page

3. CONTEXT MANAGER (in-memory)
   
   contextManager = {
     lastAction: string,
     lastTarget: string,
     lastElements: Array<HTMLElement>,
     lastClickedElement: HTMLElement,
     lastSpokenText: string,
     conversationHistory: Array<Object>,
     corrections: Array<Object>
   }
   â”œâ”€â”€ Purpose: Remember previous actions for context
   â”œâ”€â”€ History size: Last 30 interactions
   â””â”€â”€ Use cases: "click it again", "go back", "what did you say"

4. RECOGNITION STATE FLAGS
   
   isListening: boolean
   â”œâ”€â”€ Purpose: Track if recognition is active
   â””â”€â”€ Critical: Must set BEFORE calling abort/stop

   isSpeaking: boolean
   â”œâ”€â”€ Purpose: Track if TTS is active
   â””â”€â”€ Prevents command processing during speech

   voicesLoaded: boolean
   â”œâ”€â”€ Purpose: Track if speech voices are ready
   â””â”€â”€ Required before TTS can work

================================================================================
                            DRY RUN EXAMPLES
================================================================================

EXAMPLE 1: CLICKING A BUTTON
================================================================================

Scenario: User wants to click "Sign Up" button on example.com/register

STEP-BY-STEP EXECUTION:

[T=0ms] User presses Ctrl+Shift+V
  â””â”€ background.js detects keyboard event

[T=10ms] background.js:injectVoiceControl(tabId)
  â”œâ”€ Check injection cooldown: OK
  â”œâ”€ Execute dist/voiceControl.js in tab
  â””â”€ Mark tab as injected

[T=50ms] voiceControl.js IIFE starts
  â”œâ”€ Check wsVoiceControlActive: false
  â”œâ”€ Set wsVoiceControlActive = true
  â”œâ”€ Register cleanup handlers
  â””â”€ Remove old UI (none exists)

[T=100ms] Create UI wrapper
  â”œâ”€ Create div#ws-voice-wrapper
  â”œâ”€ Style: fixed, bottom:20px, right:20px, z-index:2147483647
  â”œâ”€ Create button with ğŸ¤ icon
  â”œâ”€ Append to document.body
  â””â”€ Wrapper visible (display: flex)

[T=150ms] Initialize element cache
  â”œâ”€ Call updateElementCache()
  â”œâ”€ Query buttons: 15 found (including "Sign Up")
  â”œâ”€ Query links: 8 found
  â”œâ”€ Query clickables: 5 found
  â”œâ”€ Store in elementCache
  â””â”€ Log: "ğŸ“¦ Cache updated in 23.45ms: 15 buttons, 8 links, 5 other clickables"

[T=200ms] Setup MutationObserver
  â”œâ”€ Create observer watching: childList, subtree, attributes
  â”œâ”€ Observe document.body
  â””â”€ Log: "ğŸ‘ï¸ MutationObserver activated"

[T=250ms] Setup speech recognition
  â”œâ”€ Create webkitSpeechRecognition instance
  â”œâ”€ Set continuous: true, interimResults: true
  â”œâ”€ Register event handlers: onstart, onresult, onerror, onend
  â””â”€ Store as window.wsRecognitionInstance

[T=300ms] Auto-start voice control
  â”œâ”€ Check domain: example.com
  â”œâ”€ Query chrome.storage.local for welcomedDomains
  â”œâ”€ Result: ["youtube.com", "github.com"] (example.com not in list)
  â””â”€ New domain detected

[T=350ms] Welcome message
  â”œâ”€ Call smartSpeak("Voice control activated. How can I help you?")
  â”œâ”€ Create SpeechSynthesisUtterance
  â”œâ”€ Select voice: "Google US English Female"
  â”œâ”€ Set rate: 1.1, pitch: 1.0
  â”œâ”€ Call speechSynthesis.speak(utterance)
  â””â”€ Audio plays: "Voice control activated. How can I help you?"

[T=400ms] Start recognition
  â”œâ”€ Set isListening = true
  â”œâ”€ Change button: innerHTML = 'ğŸ”´', backgroundColor = '#dc3545'
  â”œâ”€ Call recognition.start()
  â””â”€ Log: "âœ… Recognition started"

[T=450ms] recognition.onstart fires
  â””â”€ Log: "ğŸ¤ Recognition started successfully"

[T=500ms] Add domain to welcomed list
  â”œâ”€ Update welcomedDomains: ["youtube.com", "github.com", "example.com"]
  â”œâ”€ chrome.storage.local.set({welcomedDomains: [...]})
  â””â”€ Log: "ğŸ“ Domain marked as welcomed: example.com"

[T=2000ms] Welcome message finishes playing
  â””â”€ System ready for commands

[T=5000ms] USER SPEAKS: "Click on sign up button"

[T=5100ms] recognition.onresult fires
  â”œâ”€ Extract transcript: "click on sign up button"
  â”œâ”€ Check isFinal: true
  â”œâ”€ Log: "ğŸ¯ Final transcript: click on sign up button"
  â””â”€ Call processCommand("click on sign up button")

[T=5110ms] processCommand() executes
  â”œâ”€ Normalize: text = "click on sign up button"
  â”œâ”€ Check conversational keywords: false (not a greeting/thank)
  â””â”€ Call sendToSpacyServer("click on sign up button")

[T=5120ms] sendToSpacyServer() sends HTTP request
  â”œâ”€ Method: POST
  â”œâ”€ URL: http://localhost:5001/process
  â”œâ”€ Headers: Content-Type: application/json
  â”œâ”€ Body: {
  â”‚   "text": "click on sign up button",
  â”‚   "page_title": "Register - Example Site",
  â”‚   "url": "https://example.com/register"
  â”‚ }
  â””â”€ Await response...

[T=5150ms] spacy_server.py receives request
  â”œâ”€ Route: @app.route('/process', methods=['POST'])
  â”œâ”€ Parse JSON: text = "click on sign up button"
  â””â”€ Call process_text(text, page_title, url)

[T=5155ms] NLP processing begins
  â”œâ”€ Create spaCy doc: doc = nlp("click on sign up button")
  â”œâ”€ Tokenize: ["click", "on", "sign", "up", "button"]
  â”œâ”€ POS tags: ["VERB", "ADP", "VERB", "ADP", "NOUN"]
  â””â”€ Dependencies parsed

[T=5160ms] analyze_intent() executes
  â”œâ”€ Search for keywords: "click" found in text
  â”œâ”€ Check verb: token.lemma_ == "click" â†’ True
  â”œâ”€ Intent detected: "click"
  â”œâ”€ Confidence: 0.95
  â””â”€ Return ("click", 0.95)

[T=5165ms] extract_entities() executes
  â”œâ”€ Intent: "click"
  â”œâ”€ Look for target after "click on"
  â”œâ”€ Find noun phrase: "sign up button"
  â”œâ”€ Extract entities: ["sign", "up", "button"]
  â””â”€ Return ["sign up button"]

[T=5170ms] generate_response() executes
  â”œâ”€ Intent: "click"
  â”œâ”€ Target: "sign up button"
  â”œâ”€ Response templates: [
  â”‚   "Clicking on {target}",
  â”‚   "Let me click {target} for you",
  â”‚   "Opening {target}",
  â”‚   ...
  â”‚ ]
  â”œâ”€ Random selection: "Clicking on sign up button"
  â””â”€ Return response

[T=5175ms] spacy_server.py sends response
  â””â”€ JSON: {
      "action": "click",
      "target": "sign up button",
      "confidence": 0.95,
      "response": "Clicking on sign up button",
      "entities": ["sign", "up", "button"],
      "tokens": ["click", "on", "sign", "up", "button"],
      "pos_tags": ["VERB", "ADP", "VERB", "ADP", "NOUN"]
    }

[T=5185ms] voiceControl.js receives response
  â”œâ”€ Response status: 200 OK
  â”œâ”€ Parse JSON: actionData = {...}
  â””â”€ Call executeAction(actionData)

[T=5190ms] executeAction() begins
  â”œâ”€ Action: "click"
  â”œâ”€ Target: "sign up button"
  â””â”€ Response: "Clicking on sign up button"

[T=5195ms] Speak response
  â”œâ”€ Call smartSpeak("Clicking on sign up button")
  â”œâ”€ Set isSpeaking = true
  â”œâ”€ Create utterance, select voice
  â”œâ”€ speechSynthesis.speak(utterance)
  â””â”€ Audio starts: "Clicking on sign up button"

[T=5200ms] Find matching element
  â”œâ”€ Call findMatchingElement("sign up button", elementCache.buttons)
  â”œâ”€ Loop through 15 cached buttons
  â”œâ”€ Check button 1: text="Login" â†’ no match
  â”œâ”€ Check button 2: text="Sign Up" â†’ MATCH!
  â”‚   â”œâ”€ Similarity score: 0.85
  â”‚   â”œâ”€ Element: <button class="btn-primary">Sign Up</button>
  â”‚   â””â”€ Best match so far
  â”œâ”€ Continue checking remaining buttons...
  â”œâ”€ Final best match: <button class="btn-primary">Sign Up</button>
  â””â”€ Return element

[T=5210ms] Highlight element
  â”œâ”€ element.style.outline = '3px solid #ff6b6b'
  â”œâ”€ element.style.boxShadow = '0 0 10px rgba(255,107,107,0.5)'
  â””â”€ Visual feedback shows on page

[T=5220ms] Scroll to element
  â”œâ”€ element.getBoundingClientRect() â†’ visible in viewport
  â”œâ”€ Already visible, skip scroll
  â””â”€ Element ready

[T=5720ms] Click element (500ms delay)
  â”œâ”€ element.click()
  â”œâ”€ Browser fires click event
  â”œâ”€ Page navigates to registration form or next step
  â””â”€ Log: "âœ… Clicked: Sign Up"

[T=5725ms] Store in context
  â”œâ”€ contextManager.remember('click', 'sign up button', [element])
  â”œâ”€ Update lastAction = 'click'
  â”œâ”€ Update lastTarget = 'sign up button'
  â”œâ”€ Update lastClickedElement = element
  â””â”€ Add to conversationHistory

[T=6000ms] Speech finishes
  â”œâ”€ utterance.onend fires
  â”œâ”€ Set isSpeaking = false
  â””â”€ Ready for next command

[T=7220ms] Remove highlight (2000ms after click)
  â”œâ”€ element.style.outline = ''
  â”œâ”€ element.style.boxShadow = ''
  â””â”€ Visual feedback removed

[T=7500ms] recognition.onend fires (auto-restart)
  â”œâ”€ Check isListening: true
  â”œâ”€ Not speaking: true
  â”œâ”€ Wait 300ms
  â””â”€ Call recognition.start()

[T=7800ms] recognition.onstart fires
  â””â”€ System ready for next command

RESULT: Button clicked successfully, page navigated, system ready for next command

================================================================================

EXAMPLE 2: SCROLLING DOWN A PAGE
================================================================================

Scenario: User wants to scroll down on a long article page

[T=0ms] User already has voice control active (from previous session)
  â””â”€ System listening (ğŸ”´ red button visible)

[T=0ms] USER SPEAKS: "Scroll down"

[T=100ms] recognition.onresult fires
  â”œâ”€ Transcript: "scroll down"
  â”œâ”€ isFinal: true
  â””â”€ Call processCommand("scroll down")

[T=110ms] processCommand() executes
  â”œâ”€ Normalize: text = "scroll down"
  â”œâ”€ Not conversational
  â””â”€ Call sendToSpacyServer("scroll down")

[T=120ms] HTTP POST to localhost:5001/process
  â””â”€ Body: {"text": "scroll down", "page_title": "Article", "url": "..."}

[T=150ms] spacy_server.py processes
  â”œâ”€ doc = nlp("scroll down")
  â”œâ”€ Tokens: ["scroll", "down"]
  â”œâ”€ analyze_intent(): "scroll" keyword found
  â”œâ”€ extract_entities(): direction = "down"
  â”œâ”€ generate_response(): "Scrolling down"
  â””â”€ Return: {
      "action": "scroll_down",
      "target": "down",
      "confidence": 0.98,
      "response": "Scrolling down"
    }

[T=180ms] voiceControl.js receives response
  â””â”€ Call executeAction(actionData)

[T=190ms] executeAction() for scroll_down
  â”œâ”€ Speak: "Scrolling down"
  â”œâ”€ No element highlighting needed
  â”œâ”€ Calculate scroll amount: window.innerHeight * 0.8 = 600px
  â”œâ”€ Execute: window.scrollBy({ top: 600, behavior: 'smooth' })
  â”œâ”€ Page smoothly scrolls down 600px
  â””â”€ Store in context: lastAction = 'scroll_down'

[T=190ms - T=800ms] Smooth scroll animation
  â””â”€ Page content moves up

[T=800ms] Scroll complete
  â””â”€ Log: "âœ… Scrolled down"

[T=1000ms] Scroll event fires (debounced check)
  â”œâ”€ scrollUpdateTimer triggers
  â”œâ”€ Check cache age: 2000ms old
  â”œâ”€ Log: "ğŸ“œ Scroll detected - checking for new content"
  â””â”€ Call forceUpdateCache()

[T=1050ms] Cache update completes
  â”œâ”€ New elements loaded (lazy-load articles)
  â”œâ”€ Cache updated: 18 buttons (was 15), 25 links (was 8)
  â””â”€ Log: "ğŸ“¦ Cache updated in 28.34ms: 18 buttons, 25 links, 7 other clickables"

[T=1200ms] recognition.onend â†’ auto-restart
  â””â”€ System ready for next command

RESULT: Page scrolled down 600px, new content cached, ready for next command

================================================================================

EXAMPLE 3: OPENING DROPDOWN MENU AND CLICKING ITEM
================================================================================

Scenario: User wants to open a navigation dropdown and click "Settings"

[T=0ms] User on dashboard.example.com (already welcomed)
  â””â”€ Voice control active, listening

[T=0ms] USER SPEAKS: "Click on settings"

[T=100ms] recognition.onresult
  â”œâ”€ Transcript: "click on settings"
  â””â”€ Call processCommand("click on settings")

[T=110ms] Send to NLP server
  â””â”€ POST localhost:5001/process

[T=150ms] NLP processing
  â”œâ”€ Intent: "click"
  â”œâ”€ Target: "settings"
  â”œâ”€ Response: "Clicking on settings"
  â””â”€ Return action data

[T=180ms] executeAction("click", "settings")
  â”œâ”€ Speak: "Clicking on settings"
  â””â”€ Call findMatchingElement("settings", elementCache.buttons)

[T=185ms] Search for "settings" element
  â”œâ”€ Check buttons: no direct "Settings" button visible
  â”œâ”€ Check links: found <a>Settings</a> but inside closed dropdown
  â”œâ”€ Element currently hidden (display: none)
  â””â”€ No match found in visible elements

[T=190ms] No element found
  â”œâ”€ Speak: "I couldn't find settings. Could you be more specific?"
  â””â”€ Log: "âŒ No match found for: settings"

[T=500ms] User tries again differently

[T=500ms] USER SPEAKS: "Open account menu"

[T=600ms] Process command â†’ NLP
  â”œâ”€ Intent: "click"
  â”œâ”€ Target: "account menu"
  â””â”€ Response: "Opening account menu"

[T=650ms] executeAction("click", "account menu")
  â”œâ”€ findMatchingElement("account menu", elementCache.buttons)
  â”œâ”€ Found: <button id="account-menu-btn">Account â–¼</button>
  â””â”€ Match score: 0.82

[T=660ms] Click account menu button
  â”œâ”€ Highlight element
  â”œâ”€ Scroll to view (already visible)
  â”œâ”€ Wait 500ms
  â””â”€ element.click()

[T=1160ms] Button clicked
  â”œâ”€ Dropdown menu appears (JavaScript triggered)
  â”œâ”€ DOM mutation detected
  â””â”€ MutationObserver fires

[T=1165ms] MutationObserver detects change
  â”œâ”€ Check mutations: added nodes detected
  â”œâ”€ Check for important changes: <ul role="menu"> found
  â”œâ”€ Important change: TRUE
  â”œâ”€ Log: "âš¡ Important DOM change detected - updating cache immediately"
  â””â”€ Call updateElementCache() (no debounce)

[T=1166ms] Immediate cache update
  â”œâ”€ Query elements again
  â”œâ”€ Found new links in dropdown:
  â”‚   - <a>Profile</a>
  â”‚   - <a>Settings</a>  â† NOW VISIBLE!
  â”‚   - <a>Logout</a>
  â”œâ”€ Add to elementCache.links
  â””â”€ Log: "ğŸ“¦ Cache updated in 12.56ms: 15 buttons, 11 links, 5 other clickables"

[T=2000ms] Dropdown fully open and cached
  â””â”€ System ready

[T=3000ms] USER SPEAKS: "Click on settings"

[T=3100ms] Process command â†’ NLP â†’ executeAction

[T=3150ms] findMatchingElement("settings", elementCache.links)
  â”œâ”€ Check links in cache
  â”œâ”€ Found: <a href="/settings">Settings</a>
  â”œâ”€ Match score: 1.0 (exact match)
  â””â”€ Return element

[T=3160ms] Click settings link
  â”œâ”€ Highlight element (inside dropdown)
  â”œâ”€ Scroll to view
  â”œâ”€ Wait 500ms
  â””â”€ element.click()

[T=3660ms] Link clicked
  â”œâ”€ Browser navigates to /settings page
  â””â”€ Log: "âœ… Clicked: Settings"

[T=3665ms] Page navigation starts
  â”œâ”€ beforeunload event fires
  â”œâ”€ cleanup() called
  â”œâ”€ Stop recognition
  â”œâ”€ Cancel speech
  â””â”€ Log: "ğŸ“„ Page unloading - cleaning up voice control"

[T=3800ms] New page loads (/settings)
  â”œâ”€ webNavigation.onCompleted fires in background.js
  â”œâ”€ Auto re-inject voice control
  â””â”€ Call injectVoiceControl(tabId)

[T=3900ms] Voice control re-injected on /settings page
  â”œâ”€ Check domain: dashboard.example.com (still same domain)
  â”œâ”€ Query welcomedDomains: ["...dashboard.example.com..."]
  â”œâ”€ Already welcomed: TRUE
  â”œâ”€ Log: "ğŸ”‡ Skipping welcome message - already welcomed on this domain"
  â”œâ”€ Start listening silently (no speech)
  â””â”€ System ready for commands

RESULT: Dropdown opened, settings clicked, navigated to settings page,
        voice control auto-restarted WITHOUT welcome message (same domain)

================================================================================
                        PERFORMANCE METRICS
================================================================================

TYPICAL LATENCIES:

Voice Recognition:
  - Silence detection: 500-1000ms after speaking stops
  - Final transcript ready: 100-200ms after detection
  - Total speech-to-text: 600-1200ms

NLP Processing (spaCy):
  - Simple commands (click, scroll): 20-50ms
  - Complex commands (multi-entity): 50-150ms
  - Network round-trip: 10-30ms (localhost)
  - Total NLP pipeline: 40-200ms

Action Execution:
  - Element search: 5-20ms (cached)
  - Highlight + scroll: 100-300ms
  - Click delay: 500ms (intentional, for visual feedback)
  - Total execution: 605-820ms

Text-to-Speech:
  - Short phrases (3-5 words): 1-2 seconds
  - Medium phrases (8-12 words): 2-3 seconds
  - Voice loading: 0-2000ms (first time only)

DOM Operations:
  - Cache update (small page): 10-30ms
  - Cache update (large page): 30-100ms
  - MutationObserver reaction: 0-200ms (debounced)
  - Scroll detection: 1000ms (debounced)

TOTAL END-TO-END LATENCY:
  - User speaks "click button" â†’ Button clicked
  - Speech recognition: 800ms
  - NLP processing: 100ms
  - Response speech: 1500ms
  - Element find + click: 800ms
  - Total: ~3200ms (3.2 seconds)

OPTIMIZATION STRATEGIES:
  - Element caching: Avoid repeated DOM queries
  - Smart debouncing: Immediate for important, delayed for normal
  - Passive listeners: scroll, mousemove (non-blocking)
  - Lazy updates: Only update cache when needed (age > 2s)
  - Parallel operations: Speak while searching elements
  - Preloading: Voices loaded on initialization

================================================================================
                            ERROR HANDLING
================================================================================

1. SPEECH RECOGNITION ERRORS

   recognition.onerror (Line 1272-1310):
   â”œâ”€â”€ Error: 'no-speech' â†’ Speak "I didn't hear anything"
   â”œâ”€â”€ Error: 'audio-capture' â†’ Speak "Microphone not available"
   â”œâ”€â”€ Error: 'not-allowed' â†’ Speak "Microphone permission denied"
   â”œâ”€â”€ Error: 'network' â†’ Retry after 2 seconds
   â””â”€â”€ Error: 'aborted' â†’ Normal stop, no action

2. NLP SERVER ERRORS

   sendToSpacyServer error handling (Line 820-850):
   â”œâ”€â”€ Network error â†’ Speak "Connection to NLP server failed"
   â”œâ”€â”€ Timeout (5s) â†’ Speak "Request timed out"
   â”œâ”€â”€ Server error 500 â†’ Speak "Server error occurred"
   â””â”€â”€ Invalid response â†’ Log error, no action

3. ELEMENT NOT FOUND

   findMatchingElement returns null (Line 1050-1080):
   â”œâ”€â”€ No match found â†’ Speak "I couldn't find {target}"
   â”œâ”€â”€ Multiple matches â†’ Use best similarity score
   â””â”€â”€ Ambiguous match â†’ Ask for clarification

4. PERMISSION ERRORS

   Microphone permission:
   â”œâ”€â”€ Check: navigator.permissions.query({name: 'microphone'})
   â”œâ”€â”€ Denied â†’ Show UI message, disable voice control
   â””â”€â”€ Prompt â†’ Request permission on first use

5. PAGE NAVIGATION ERRORS

   Cleanup failures:
   â”œâ”€â”€ recognition.stop() error â†’ Ignore (page unloading)
   â”œâ”€â”€ speechSynthesis.cancel() error â†’ Ignore
   â””â”€â”€ Re-injection fails â†’ Retry on next navigation

================================================================================
                        SECURITY CONSIDERATIONS
================================================================================

1. CONTENT SECURITY POLICY (CSP)
   - Extension uses inline scripts (allowed for extensions)
   - API calls restricted to localhost (development)
   - No eval() or unsafe practices

2. PERMISSION MODEL
   - Microphone: Required for speech recognition
   - activeTab: Only active tab access
   - storage: Local storage only
   - No broad host permissions

3. INPUT SANITIZATION
   - All user speech sanitized before NLP
   - No direct eval of commands
   - Command whitelist in spaCy server

4. DATA PRIVACY
   - No speech data sent to external servers
   - No user data persistence (except welcomed domains)
   - All processing local (localhost)

5. INJECTION PROTECTION
   - Duplicate injection prevention (wsVoiceControlActive flag)
   - Cooldown timers (2 seconds between injections)
   - IIFE pattern prevents global scope pollution

================================================================================
                            TROUBLESHOOTING
================================================================================

COMMON ISSUES AND SOLUTIONS:

Issue: Voice control not activating
â”œâ”€â”€ Check: Microphone permissions in chrome://settings/content
â”œâ”€â”€ Check: Extension enabled in chrome://extensions
â”œâ”€â”€ Check: NLP server running (localhost:5001)
â””â”€â”€ Solution: Reload extension, restart servers

Issue: Commands not recognized
â”œâ”€â”€ Check: Speech recognition language (en-US)
â”œâ”€â”€ Check: Background noise (use quiet environment)
â”œâ”€â”€ Check: NLP server logs for processing errors
â””â”€â”€ Solution: Speak clearly, check server response

Issue: Buttons not clicking
â”œâ”€â”€ Check: Element cache updated (console logs)
â”œâ”€â”€ Check: Button actually visible on page
â”œâ”€â”€ Check: Button text matches command
â””â”€â”€ Solution: Refresh cache, use exact button text

Issue: Welcome message every page
â”œâ”€â”€ Check: Domain in welcomedDomains list
â”œâ”€â”€ Check: chrome.storage.local permissions
â””â”€â”€ Solution: Clear storage, reload extension

Issue: Voice control stops after navigation
â”œâ”€â”€ Check: Auto re-injection enabled (background.js)
â”œâ”€â”€ Check: Cleanup handlers firing correctly
â”œâ”€â”€ Check: Console for injection logs
â””â”€â”€ Solution: Check webNavigation.onCompleted listener

================================================================================
                            CONCLUSION
================================================================================

This documentation covers the complete technical flow of WebSense-AI from
user activation to command execution. The system uses a multi-layered
architecture with Chrome Extension (frontend), Node.js API (middleware), and
Python spaCy NLP (backend) to provide natural language voice control for web
browsing.

Key strengths:
- Fast element caching with smart updates
- Robust error handling and auto-recovery
- Context-aware conversational interface
- Smooth user experience with minimal latency
- Secure local processing (no external API calls for voice)

The three detailed examples demonstrate common use cases and show the exact
execution flow with timing, function calls, and data transformations at each
step.

For developers: All function references include file locations and line numbers
for easy code navigation and debugging.

Last Updated: November 24, 2025
Version: 1.0
